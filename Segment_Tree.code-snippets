{
	"Segment_Tree": {
		"prefix": "Segment_Tree",
		"body": [
		  "template < typename T = int, int Mode = 0 > struct Segment_Tree {",
		  "",
		  "    struct Node {",
		  "",
		  "        ll val;",
		  "",
		  "        Node(ll V = 0) : val(V) {}",
		  "    ",
		  "        Node operator = (const T rhs) {",
		  "            val = rhs;",
		  "            return *this;",
		  "        }",
		  "",
		  "    };",
		  "",
		  "    int size; ",
		  "    Node DEFAULT;",
		  "    vector < Node > tree; ",
		  "    ",
		  "    void intial(int n){",
		  "        size = 1, DEFAULT = 0;",
		  "        while(size < n) size *= 2;",
		  "        tree = vector < Node > (2 * size, DEFAULT);",
		  "    }",
		  "",
		  "    Segment_Tree(int n){",
		  "        intial(n);",
		  "    }",
		  "",
		  "    // Main operation to do",
		  "",
		  "    Node operation(Node a, Node b){",
		  "        return a.val + b.val;",
		  "    }",
		  "    ",
		  "    // If Mode is 1 so the array is 1-based else the array is 0-based",
		  "    ",
		  "    void build(vector < T >& nums, int idx, int lx, int rx){",
		  "        if(Mode ? lx >= sz(nums) : lx > sz(nums)) return;",
		  "        if(rx == lx) tree[idx] = nums[lx - !Mode];",
		  "        else {",
		  "            int m = (rx + lx) / 2;",
		  "            build(nums, 2 * idx, lx, m);",
		  "            build(nums, 2 * idx + 1, m + 1, rx);",
		  "            tree[idx] = operation(tree[2 * idx], tree[2 * idx + 1]);",
		  "        }",
		  "    }",
		  "",
		  "    void build(vector < T >& nums){",
		  "        build(nums, 1, 1, size);",
		  "    }",
		  "",
		  "    void update(int i, T v, int idx, int lx, int rx){",
		  "        if(rx == lx) tree[idx] = v;",
		  "        else {  ",
		  "            int m = (rx + lx) / 2;",
		  "            if(i <= m) update(i, v, 2 * idx, lx, m);",
		  "            else update(i, v, 2 * idx + 1, m + 1, rx);",
		  "            tree[idx] = operation(tree[2 * idx], tree[2 * idx + 1]);",
		  "        }",
		  "    }",
		  "",
		  "    void update(int i, int v){",
		  "        update(i, v, 1, 1, size);",
		  "    }",
		  "",
		  "    Node query(int l, int r, int idx, int lx, int rx){",
		  "        if(lx > r || l > rx) return DEFAULT;",
		  "        if(lx >= l && rx <= r) return tree[idx];",
		  "        int m = (lx + rx) / 2;",
		  "        return operation(query(l, r, 2 * idx, lx, m), query(l, r, 2 * idx + 1, m + 1, rx));",
		  "    }",
		  "",
		  "    Node query(int l, int r){",
		  "        return query(l, r, 1, 1, size);",
		  "    }",
		  "",
		  "    friend ostream& operator << (ostream &out, const Node &node) {",
		  "        out << node.val;",
		  "        return out;",
		  "    }",
		  "    ",
		  "};"
		],
		"description": "Segment_Tree"
	}
}